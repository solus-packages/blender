--- a/build_files/cmake/Modules/FindUSD.cmake
+++ b/build_files/cmake/Modules/FindUSD.cmake
@@ -38,7 +38,7 @@ FIND_PATH(USD_INCLUDE_DIR
 
 FIND_LIBRARY(USD_LIBRARY
   NAMES
-    usd_m usd_ms
+    usd_m usd_ms usd_usd_ms
   NAMES_PER_DIR
   HINTS
     ${_usd_SEARCH_DIRS}
--- a/build_files/cmake/platform/platform_unix.cmake
+++ b/build_files/cmake/platform/platform_unix.cmake
@@ -307,7 +307,7 @@ if(WITH_BOOST)
       set(Boost_USE_STATIC_LIBS ON)
     endif()
     set(Boost_USE_MULTITHREADED ON)
-    set(__boost_packages filesystem regex thread date_time)
+    set(__boost_packages filesystem regex thread date_time python)
     if(WITH_CYCLES_OSL)
       if(NOT (${OSL_LIBRARY_VERSION_MAJOR} EQUAL "1" AND ${OSL_LIBRARY_VERSION_MINOR} LESS "6"))
         list(APPEND __boost_packages wave)
--- a/source/blender/io/usd/CMakeLists.txt
+++ b/source/blender/io/usd/CMakeLists.txt
@@ -52,6 +52,7 @@ set(INC
 set(INC_SYS
   ${USD_INCLUDE_DIRS}
   ${BOOST_INCLUDE_DIR}
+  ${PYTHON_INCLUDE_DIRS}
   ${TBB_INCLUDE_DIR}
 )
 
@@ -86,6 +87,8 @@
 
 list(APPEND LIB
   ${BOOST_LIBRARIES}
+  ${PYTHON_LINKFLAGS}
+  ${PYTHON_LIBRARIES}
 )
 
 list(APPEND LIB
--- a/source/blender/io/usd/intern/usd_reader_light.cc
+++ b/source/blender/io/usd/intern/usd_reader_light.cc
@@ -25,7 +25,7 @@
 #include "DNA_light_types.h"
 #include "DNA_object_types.h"
 
-#include <pxr/usd/usdLux/light.h>
+#include <pxr/usd/usdLux/lightAPI.h>
 
 #include <pxr/usd/usdLux/diskLight.h>
 #include <pxr/usd/usdLux/distantLight.h>
@@ -57,7 +57,7 @@ void USDLightReader::read_object_data(Ma
     return;
   }
 
-  pxr::UsdLuxLight light_prim(prim_);
+  pxr::UsdLuxLightAPI light_prim(prim_);
 
   if (!light_prim) {
     return;
--- a/source/blender/io/usd/intern/usd_reader_stage.cc
+++ b/source/blender/io/usd/intern/usd_reader_stage.cc
@@ -34,7 +34,7 @@
 #include <pxr/usd/usdGeom/nurbsCurves.h>
 #include <pxr/usd/usdGeom/scope.h>
 #include <pxr/usd/usdGeom/xform.h>
-#include <pxr/usd/usdLux/light.h>
+#include <pxr/usd/usdLux/lightAPI.h>
 
 #include <iostream>
 
@@ -71,7 +71,7 @@ USDPrimReader *USDStageReader::create_re
   if (params_.import_meshes && prim.IsA<pxr::UsdGeomMesh>()) {
     return new USDMeshReader(prim, params_, settings_);
   }
-  if (params_.import_lights && prim.IsA<pxr::UsdLuxLight>()) {
+  if (params_.import_lights && prim.IsA<pxr::UsdLuxLightAPI>()) {
     return new USDLightReader(prim, params_, settings_);
   }
   if (params_.import_volumes && prim.IsA<pxr::UsdVolVolume>()) {
@@ -98,7 +98,7 @@ USDPrimReader *USDStageReader::create_re
   if (prim.IsA<pxr::UsdGeomMesh>()) {
     return new USDMeshReader(prim, params_, settings_);
   }
-  if (prim.IsA<pxr::UsdLuxLight>()) {
+  if (prim.IsA<pxr::UsdLuxLightAPI>()) {
     return new USDLightReader(prim, params_, settings_);
   }
   if (prim.IsA<pxr::UsdVolVolume>()) {
--- a/source/blender/io/usd/intern/usd_reader_xform.cc
+++ b/source/blender/io/usd/intern/usd_reader_xform.cc
@@ -148,7 +148,7 @@ bool USDXformReader::is_root_xform_prim(
     return false;
   }
 
-  if (prim_.IsInMaster()) {
+  if (prim_.IsInPrototype()) {
     /* We don't consider prototypes to be root prims,
      * because we never want to apply global scaling
      * or rotations to the prototypes themselves. */
--- a/source/blender/io/usd/intern/usd_writer_abstract.cc
+++ b/source/blender/io/usd/intern/usd_writer_abstract.cc
@@ -106,7 +106,7 @@ pxr::UsdShadeMaterial USDAbstractWriter:
   shader.CreateInput(usdtokens::metallic, pxr::SdfValueTypeNames->Float).Set(material->metallic);
 
   /* Connect the shader and the material together. */
-  usd_material.CreateSurfaceOutput().ConnectToSource(shader, usdtokens::surface);
+  usd_material.CreateSurfaceOutput().ConnectToSource(shader.ConnectableAPI(), usdtokens::surface);
 
   return usd_material;
 }
--- a/source/blender/io/usd/intern/usd_writer_light.cc
+++ b/source/blender/io/usd/intern/usd_writer_light.cc
@@ -49,7 +49,7 @@ void USDLightWriter::do_write(HierarchyC
   pxr::UsdTimeCode timecode = get_export_time_code();
 
   Light *light = static_cast<Light *>(context.object->data);
-  pxr::UsdLuxLight usd_light;
+  pxr::UsdLuxLightAPI usd_light;
 
   switch (light->type) {
     case LA_AREA:
@@ -58,21 +58,21 @@ void USDLightWriter::do_write(HierarchyC
         case LA_AREA_ELLIPSE: { /* An ellipse light will deteriorate into a disk light. */
           pxr::UsdLuxDiskLight disk_light = pxr::UsdLuxDiskLight::Define(stage, usd_path);
           disk_light.CreateRadiusAttr().Set(light->area_size, timecode);
-          usd_light = disk_light;
+          usd_light = disk_light.LightAPI();
           break;
         }
         case LA_AREA_RECT: {
           pxr::UsdLuxRectLight rect_light = pxr::UsdLuxRectLight::Define(stage, usd_path);
           rect_light.CreateWidthAttr().Set(light->area_size, timecode);
           rect_light.CreateHeightAttr().Set(light->area_sizey, timecode);
-          usd_light = rect_light;
+          usd_light = rect_light.LightAPI();
           break;
         }
         case LA_AREA_SQUARE: {
           pxr::UsdLuxRectLight rect_light = pxr::UsdLuxRectLight::Define(stage, usd_path);
           rect_light.CreateWidthAttr().Set(light->area_size, timecode);
           rect_light.CreateHeightAttr().Set(light->area_size, timecode);
-          usd_light = rect_light;
+          usd_light = rect_light.LightAPI();
           break;
         }
       }
@@ -80,11 +80,11 @@ void USDLightWriter::do_write(HierarchyC
     case LA_LOCAL: {
       pxr::UsdLuxSphereLight sphere_light = pxr::UsdLuxSphereLight::Define(stage, usd_path);
       sphere_light.CreateRadiusAttr().Set(light->area_size, timecode);
-      usd_light = sphere_light;
+      usd_light = sphere_light.LightAPI();
       break;
     }
     case LA_SUN:
-      usd_light = pxr::UsdLuxDistantLight::Define(stage, usd_path);
+      usd_light = pxr::UsdLuxDistantLight::Define(stage, usd_path).LightAPI();
       break;
     default:
       BLI_assert(!"is_supported() returned true for unsupported light type");
